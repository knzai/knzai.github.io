---
layout: post
title: "The holy grail of image formats: SVG cross-codec-compilation & AVIF"
image: /assets/img/posts/svg-ccc/100.avif
description: >
  Photos and text or diagrams in the same image file, at a small size, without losing cripsness
toot_id: 113064123926263617
---

When using images on the web you've always had to choose between size and quality. This gets particularly pointed when you have one image containing both a photo and crisp lines (for instance text or a diagram). Compressing both of those in the same image will generally either require a large image, or the compression artifacts will become apparent, especially around the crisp lines.

For instance, here's the header image for this post, originally a 627kb PNG, compressed to a 18kb jpg (a "25% quality" setting in the app I was using), to exaggerate the effect beyond what you'd ever typically settle on:

![](/assets/img/posts/svg-ccc/25.jpg)


But now SVG support is good enough that you can avoid this by using an SVG as a container for two images with different codecs/formats that are Base64 data encoded directly into the same file:

```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <image xlink:href="data:image/png;base64,[DATA]"/>
  <image xlink:href="data:image/jpg;base64,[DATA]"/>
```

This lets you optimize the the photo down to a reasonable size, without having to negatively impact your text/diagram rendering. And not having to use two separate image files via html and css is better for optimizing mobile loading (with fewer separate requests to the server) and handles scaling to different resolutions smoothly without any additional css fiddling.

To optimize this further, I started playing around with different compression approaches for the photo, and realized that we can now pretty much [just use AVIF](https://caniuse.com/avif), a better replacement even than jpg2000. Pretty quickly I discovered that the image size vs quality tradeofss were such that you might as well just use an AVIF for the whole things, rather than the complexity of layering a png and avif into one file, for comparable quality and size.

Lossless avif of the whole file cut it down to to 413kb while taking it all the way down to a similar 25%, at 15kn being even smaller than the crappy jpg, without the horrendous artifacts it displayed:

![](/assets/img/posts/svg-ccc/25.avif)

You can of course adjust to wherever in between.  If you want really crisp lines for a decent size, you could also try using a webp image in place of a png with the avif. Really, though, if you truly want lines that crisp, you should already be using a vector instead anyways. Since we were already using a SVG for the compositing, lets just do everything but the photo in the svg itself, and then layer in a well-compressed AVIF for the photo.

This is the result I ended up on for this header, originally (I ended up using an AVIF after all, for now, so I didn' have to deal with hacking the jekyll plugin to use a separate image for the OpenGraph share. I'll probably swap back to the smaller and crisper svg-ccc). The font, gradient, and overlay are all done in SVG making it even easier to swap in different photos (svg autogenerated by Figma then cleaned up a bit via [svgviewer.dev](https://www.svgviewer.dev)).  

```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="none" viewBox="0 0 918 560">
  <g clip-path="url(#a)">
    <path fill="url(#b)" d="M-134 0H918v560H-134z"/>
    <g filter="url(#c)" style="mix-blend-mode:overlay">
      <path fill="url(#c)" d="M423 0h496v560H423z" shape-rendering="crispEdges"/>
    </g>
    <path fill="#fff" d="M52.078 311.608q-3.343 0-6.457-.76t-5.127-1.975l2.886-6.533q1.899 1.103 4.216 1.785 2.355.646 
..."/>
  </g>
  <defs>
    <linearGradient id="b" x1="-355.072" x2="190.854" y1="369.927" y2="-569.885" gradientUnits="userSpaceOnUse">
      <stop stop-color="#B45BCF"/>
      <stop offset="1" stop-color="#6E57FF"/>
    </linearGradient>
    <clipPath id="a">
      <rect width="918" height="560" fill="#fff" rx="7"/>
    </clipPath>
    <pattern id="c" width="1" height="1" patternContentUnits="objectBoundingBox">
      <use xlink:href="#d" transform="matrix(.00204 0 0 .00184 -.013 -.03)"/>
    </pattern>
    <image id="d" xlink:href="data:image/png;base64,...
```

Tools like Figma usually don't support AVIF yet, so you may have to do something like export the SVG with just the raw png in the svg, delete out it's href and replace it with the avif data. This can get a little cumbersome, and it may just be worth it using a reasonably well encoding AVIF.  Hopefully the tooling starts supporting AVIF more broadly and it will get a little simpler.

You'll need a non-SVG photo for your OpenGraph preview anyway, so in the case of header images for pages, it may extra not be worth it doing the SVG shuffle.  And if you really want to optimize your mobile loading you may want to make separate SVGs for the different responsive sizes and that starts getting annoying without rolling some additional tooling, as you can't just use ImageMagic or some other tools frequently used to autogenerate the different sized. Thankfully you can get filesizes down small enough it may not even be worth it either way though

This small filesize also offsets one of the few disadvantages of AVIF, it doesn't do progressive rendering while it's not downloaded yet, like jpg does. But, given the smaller sizes you can acheive, it's still probably worth using AVIF, since the whole file will be loaded in the same time the progressive rendering would start.

So overall, you can just use AVIF 90% of the time and adjust the quality to a decent trade-offs. In cases where that isn't sufficient, you can stick the AVIF into a SVG like a displayed and layer in different images of whatever format, though in my case the png usage wasn't enough of an improvment. Webp probably works out well, but then why not just use vectors anyway.
